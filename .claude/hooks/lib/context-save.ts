#!/usr/bin/env bun

/**
 * context-save.ts
 *
 * Library for saving project context on session exit.
 * Called by stop-hook.ts based on pai-config.json settings.
 *
 * Settings in pai-config.json:
 *   context.onExit: "prompt" | "auto-save" | "none"
 *
 * Context is saved to:
 *   - ./project-context.md (if it already exists)
 *   - ./.claude/context.md (if .claude/ exists)
 *   - ./CONTEXT.md (fallback)
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { homedir } from 'os';

const PAI_CONFIG_PATH = join(homedir(), '.claude', 'pai-config.json');

interface ContextConfig {
  onLoad: 'auto-load' | 'notify' | 'none';
  onExit: 'prompt' | 'auto-save' | 'none';
}

interface PaiConfig {
  context?: ContextConfig;
}

/**
 * Get context configuration from pai-config.json
 */
export function getContextConfig(): ContextConfig {
  const defaults: ContextConfig = {
    onLoad: 'auto-load',
    onExit: 'none'
  };

  try {
    if (!existsSync(PAI_CONFIG_PATH)) {
      return defaults;
    }

    const config: PaiConfig = JSON.parse(readFileSync(PAI_CONFIG_PATH, 'utf-8'));
    return {
      onLoad: config.context?.onLoad || defaults.onLoad,
      onExit: config.context?.onExit || defaults.onExit
    };
  } catch (e) {
    console.error('⚠️ Could not read pai-config.json, using defaults');
    return defaults;
  }
}

/**
 * Find the context file path for the current project
 */
export function findContextFilePath(cwd: string): string | null {
  // Check existing locations first (prefer existing file)
  const existingPaths = [
    join(cwd, 'project-context.md'),
    join(cwd, '.claude', 'context.md'),
    join(cwd, 'CONTEXT.md')
  ];

  for (const path of existingPaths) {
    if (existsSync(path)) {
      return path;
    }
  }

  // For new context, prefer .claude/context.md if .claude exists
  if (existsSync(join(cwd, '.claude'))) {
    return join(cwd, '.claude', 'context.md');
  }

  // Fall back to project-context.md in root
  return join(cwd, 'project-context.md');
}

/**
 * Generate context content from session summary
 */
export function generateContextContent(
  existingContent: string | null,
  sessionSummary: string,
  timestamp: string
): string {
  const header = `# Project Context

> Auto-generated by PAI on ${timestamp}
> This file helps PAI understand your project across sessions.

`;

  const sessionSection = `
## Latest Session Summary

${sessionSummary}

---

`;

  if (existingContent) {
    // Append to existing content, updating the session summary section
    const sessionMarker = '## Latest Session Summary';
    const markerIndex = existingContent.indexOf(sessionMarker);

    if (markerIndex !== -1) {
      // Find the end of the session section (next ## or end of file)
      const afterMarker = existingContent.slice(markerIndex + sessionMarker.length);
      const nextSectionMatch = afterMarker.match(/\n## /);
      const endOfSection = nextSectionMatch
        ? markerIndex + sessionMarker.length + nextSectionMatch.index!
        : existingContent.length;

      // Replace the session summary section
      return existingContent.slice(0, markerIndex) +
        sessionSection.trim() + '\n\n' +
        existingContent.slice(endOfSection).trim();
    } else {
      // No existing session section, append it
      return existingContent.trim() + '\n\n' + sessionSection;
    }
  }

  // New file
  return header + sessionSection;
}

/**
 * Save context to file
 */
export function saveContext(cwd: string, sessionSummary: string): { saved: boolean; path: string | null; error?: string } {
  try {
    const contextPath = findContextFilePath(cwd);

    if (!contextPath) {
      return { saved: false, path: null, error: 'Could not determine context file path' };
    }

    // Ensure directory exists
    const dir = dirname(contextPath);
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }

    // Read existing content if file exists
    let existingContent: string | null = null;
    if (existsSync(contextPath)) {
      existingContent = readFileSync(contextPath, 'utf-8');
    }

    // Generate new content
    const timestamp = new Date().toISOString();
    const newContent = generateContextContent(existingContent, sessionSummary, timestamp);

    // Write to file
    writeFileSync(contextPath, newContent, 'utf-8');

    return { saved: true, path: contextPath };
  } catch (e) {
    return { saved: false, path: null, error: String(e) };
  }
}

/**
 * Check if context should be saved based on config
 */
export function shouldSaveContext(): { save: boolean; prompt: boolean } {
  const config = getContextConfig();

  switch (config.onExit) {
    case 'auto-save':
      return { save: true, prompt: false };
    case 'prompt':
      return { save: true, prompt: true };
    case 'none':
    default:
      return { save: false, prompt: false };
  }
}

/**
 * Extract a session summary from transcript content
 */
export function extractSessionSummary(transcript: string): string {
  // Look for SUMMARY, CAPTURE, or COMPLETED sections in the transcript
  const lines = transcript.split('\n');
  const summaryParts: string[] = [];

  for (const line of lines) {
    try {
      const entry = JSON.parse(line);
      if (entry.type === 'assistant' && entry.message?.content) {
        const content = typeof entry.message.content === 'string'
          ? entry.message.content
          : entry.message.content.map((c: any) => c.text || '').join(' ');

        // Extract SUMMARY section
        const summaryMatch = content.match(/SUMMARY:\s*(.+?)(?=\n[A-Z]+:|$)/s);
        if (summaryMatch) {
          summaryParts.push(`**Summary:** ${summaryMatch[1].trim()}`);
        }

        // Extract CAPTURE section
        const captureMatch = content.match(/CAPTURE:\s*(.+?)(?=\n[A-Z]+:|$)/s);
        if (captureMatch) {
          summaryParts.push(`**Captured:** ${captureMatch[1].trim()}`);
        }

        // Extract COMPLETED section
        const completedMatch = content.match(/COMPLETED:\s*(.+?)(?=\n|$)/);
        if (completedMatch) {
          summaryParts.push(`**Completed:** ${completedMatch[1].trim()}`);
        }
      }
    } catch {
      // Skip non-JSON lines
    }
  }

  if (summaryParts.length === 0) {
    return 'Session completed without explicit summary.';
  }

  return summaryParts.join('\n\n');
}
